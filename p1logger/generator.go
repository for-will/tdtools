package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
)

type StructDecl struct {
	Name   string
	Fields []*StructFieldDecl
}

type StructFieldDecl struct {
	Name    string
	Type    string
	JsonTag string
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.SetPrefix("[p1logger] ")
	src := BuildMarshallerAuto()

	out, err := format.Source([]byte(src))
	if err != nil {
		out = []byte(src)
	}
	err = ioutil.WriteFile("marshaller_auto.go", out, 0644)
	if err != nil {
		log.Fatalf("output file: marshaller_auto.go error: %v", err)
	}
	fmt.Printf("output file: marshaller_auto.go")
}

func BuildMarshallerAuto() string {

	var sb strings.Builder

	sb.WriteString(`// Code generated by "p1logger". DO NOT EDIT.

//go:generate p1logger

package logs

import (
	"go.uber.org/zap/zapcore"
)
`)
	pkg := loadPackage()
	if pkg == nil || len(pkg.Syntax) == 0 {
		log.Fatal("load package syntax empty")
	}

	logObjs := parseLogStruct(pkg.Syntax[0])
	for _, v := range logObjs {
		sb.WriteString(genObjectMemFunc(v))
	}
	return sb.String()
}

func genObjectMemFunc(typ *StructDecl) string {

	var sb strings.Builder

	mf := genMarshallerFunc(typ)
	sb.WriteString("\n")
	sb.WriteString(mf)

	cf := genFixCaiFunc(typ)
	sb.WriteString("\n")
	sb.WriteString(cf)
	return sb.String()
}

func genMarshallerFunc(typ *StructDecl) string {

	var sb strings.Builder
	sb.WriteString(
		fmt.Sprintf("func (obj *%s) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n", typ.Name),
	)

	var omitempty = map[string]string{
		"old_accountid": `""`,
		"axis":          `""`,
		"offline_money": `""`,
		"offline_exp":   `""`,
		"offlineitem":   `""`,
		"item_sum":      `""`,
		"money_sum":     `0`,
		"exp_sum":       `0`,
	}

	for _, f := range typ.Fields {
		k := f.JsonTag
		var addType = f.Type
		addType = strings.ToUpper(addType[:1]) + addType[1:]
		val := f.Name
		if addType == "Detail" {
			addType = "String"
			val = val + ".String()"
		}

		if addType == "StringArray" {
			addType = "Array"
		}

		if empty, ok := omitempty[k]; ok {
			sb.WriteString(fmt.Sprintf("if obj.%s != %s{\n", f.Name, empty))
			sb.WriteString(
				fmt.Sprintf("enc.Add%s(\"%s\", obj.%s)\n", addType, k, val),
			)
			sb.WriteString("}\n")
		} else {
			sb.WriteString(
				fmt.Sprintf("enc.Add%s(\"%s\", obj.%s)\n", addType, k, val),
			)
		}

	}
	sb.WriteString("return nil\n}\n")
	return sb.String()
}

func genFixCaiFunc(typ *StructDecl) string {
	var sb strings.Builder
	sb.WriteString(
		fmt.Sprintf("func (obj *%s) FixCai(provider CaiProvider) {\n", typ.Name),
	)

	for _, field := range typ.Fields {

		getter, ok := getterMethodsName[field.JsonTag]
		if !ok {
			continue
		}
		sb.WriteString(
			fmt.Sprintf("obj.%s = provider.%s()\n", field.Name, getter),
		)
	}
	sb.WriteString("}\n")
	return sb.String()
}

func parseLogStruct(file *ast.File) []*StructDecl {

	var structs []*StructDecl

	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structs = append(structs, &StructDecl{
				Name:   typeSpec.Name.Name,
				Fields: extractStructFields(structType.Fields),
			})
		}
	}
	return structs
}

func loadPackage() *packages.Package {
	cfg := &packages.Config{
		Mode:  packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes | packages.NeedName,
		Tests: false,
	}
	pkgs, err := packages.Load(cfg, "operates.go")
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	return pkgs[0]
}

func extractStructFields(fl *ast.FieldList) []*StructFieldDecl {
	var fields []*StructFieldDecl
	for _, field := range fl.List {

		switch field.Type.(type) {
		case *ast.Ident:
			typ := field.Type.(*ast.Ident)
			typeName := typ.Name

			for _, name := range field.Names {
				fields = append(fields, &StructFieldDecl{
					Name:    name.Name,
					Type:    typeName,
					JsonTag: extractJsonTag(field.Tag.Value),
				})
			}

		case *ast.InterfaceType:
			//typ := field.Type.(*ast.InterfaceType)
			//typeName := "Reflected"

			for _, name := range field.Names {
				fields = append(fields, &StructFieldDecl{
					Name:    name.Name,
					Type:    "Reflected",
					JsonTag: extractJsonTag(field.Tag.Value),
				})
			}

		default:
			log.Printf("%#v", field.Type)
			log.Println(field.Names)
		}

	}
	return fields
}

func extractJsonTag(meta string) string {
	re := regexp.MustCompile(`json:"(\w+)"`)
	matches := re.FindAllStringSubmatch(meta, -1)
	if len(matches) > 0 {
		return matches[0][1]
	}
	return ""
}

var getterMethodsName = map[string]string{
	"ip":               "GetIpv4",
	"ip4":              "GetIpv4",
	"ipv4":             "GetIpv4",
	"ip6":              "GetIpv6",
	"ipv6":             "GetIpv6",
	"device_model":     "GetDeviceModel",
	"device_height":    "GetDeviceHeight",
	"device_width":     "GetDeviceWidth",
	"os_name":          "GetOsName",
	"os_ver":           "GetOsVer",
	"mac_addr":         "GetMacAddr",
	"udid":             "GetUDId",
	"app_channel":      "GetAppChannel",
	"app_ver":          "GetAppVer",
	"server":           "GetServer",
	"account_id":       "GetAccountId",
	"old_accountid":    "GetOldAccountId",
	"role_id":          "GetRoleId",
	"role_name":        "GetRoleName",
	"create_time":      "GetCreateTime",
	"sdk_ver":          "GetSdkVer",
	"imei":             "GetIMEI",
	"nation":           "GetNation",
	"role_level":       "GetRoleLevel",
	"recource":         "GetRecourseDict",
	"urs":              "GetUrs",
	"transid":          "GetTransId",
	"unisdk_deviceid":  "GetUniSdkDeviceId",
	"is_emulator":      "GetIsEmulator",
	"is_root":          "GetIsRoot",
	"country_code":     "GetCountryCode",
	"oaid":             "GetOAId",
	"engine_ver":       "GetEngineVer",
	"aid":              "GetAId",
	"aas_msg":          "GetAasMsg",
	"sauth_login_type": "GetSAuthLoginType",
	"isp":              "GetIsp",
	"network":          "GetNetwork",
}
